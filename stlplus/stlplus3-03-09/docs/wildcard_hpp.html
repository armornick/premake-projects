<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>portability/wildcard.hpp</title>
<link rel="stylesheet" type="text/css" href="shCore.css"/>
<link rel="stylesheet" type="text/css" href="shThemeSTLplus.css"/>
<script type="text/javascript" src="shCore.js"></script>
<script type="text/javascript" src="shBrushCpp.js"></script>
</head>
<body>
<h1>portability/wildcard.hpp</h1>
<pre class="brush: cpp">
#ifndef STLPLUS_WILDCARD
#define STLPLUS_WILDCARD
////////////////////////////////////////////////////////////////////////////////

//   Author:    Andy Rushton
//   Copyright: (c) Southampton University 1999-2004
//              (c) Andy Rushton           2004 onwards
//   License:   BSD License, see ../docs/license.html

//   This is a portable interface to wildcard matching.

//   The problem:
//     *  matches any number of characters - this is achieved by matching 1 and seeing if the remainder matches
//        if not, try 2 characters and see if the remainder matches etc.
//        this must be recursive, not iterative, so that multiple *s can appear in the same wildcard expression
//     ?  matches exactly one character so doesn't need the what-if approach
//     \  escapes special characters such as *, ? and [
//     [] matches exactly one character in the set - the difficulty is the set can contain ranges, e.g [a-zA-Z0-9]
//        a set cannot be empty and the ] character can be included by making it the first character

////////////////////////////////////////////////////////////////////////////////
#include &quot;portability_fixes.hpp&quot;
#include &lt;string&gt;

namespace stlplus
{

  // wild = the wildcard expression
  // match = the string to test against that expression
  // e.g. wildcard(&quot;[a-f]*&quot;, &quot;fred&quot;) returns true
  bool wildcard(const std::string&amp; wild, const std::string&amp; match);

}

#endif
</pre>
<script type="text/javascript">SyntaxHighlighter.defaults['toolbar']=false; SyntaxHighlighter.all()</script>
</body>
